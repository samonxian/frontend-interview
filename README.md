# 前端面试理论知识总结

简单的总结了一些常问的一些前端面试问题。

## HTTP 篇

> 稍微有点水平的，HTTP 多多少少也是必然会问到的问题。

HTTP 是一致无状态的应用层协议，即 HTTP 协议自身不会对请求和响应之间的通信状态进行保存。

### HTTP 状态码

> HTTP 状态码是常问的面试问题之一。

常用的状态码就那些，记住这些就足够应付面试。

下面的是总结了 5 大类的状态码。

| 状态码 | 类别         | 说明                                               |
| ------ | ------------ | -------------------------------------------------- |
| 1XX    | 信息行状态码 | 接收到请求正在处理                                 |
| 2XX    | 成功状态码   | 接收的请求成功处理完毕                             |
| 3XX    | 重定向状态码 | 需要进行附加操作才可以完成请求（如重定向）         |
| 4XX    | 客户端状态码 | 服务端无法处理请求（由于客户端响应头等错误）       |
| 5XX    | 服务端状态码 | 服务端处理请求中出现了错误（代码逻辑、网关等错误） |

其中 `1XX` 基本没人会问题，现实中也没怎么遇到，不做详细说明。

#### 2XX 成功状态码

`2XX` 最常用的就是 200，一般返回 200 代替其他 `2XX ` 也不算错。

##### 200 成功

表示从客户端的请求在服务器中被正常处理了，非严格情况下，一般只要请求成功处理了，都可以使用 `200`。

##### 201 已创建

请求成功并且服务器创建了新的资源。可以用来表示新增、修改成功。很多人一般都会以 200 来代替。

##### 202 异步

 服务器已接受请求，但尚未处理。通常用来处理服务器异步操作。这个场景我还没遇到过。

##### 204 无内容

服务器成功处理了请求，但没有返回任何内容。 

##### 206 部分内容

服务器成功处理了部分 GET 请求。一般都是请求头中设置了 `Range` 来请求指定区间字节内容，才会返回 206。使用浏览器播放 mp4 文件就会返回 206 状态码。

#### 3XX 重定向

3XX 响应结果表明浏览器需要执行某些特殊的处理，以正确方式处理请求。一般我们总结为重定向，但是这里有一个特殊的存在 `304`，并不是重定向，这个是我们需要注意的。304 是常用状态码，其他的 3XX 相对比较少用。

##### 301 永久移动

资源永久重定向，该状态表示请求的资源已经被分配了新的 URI 。

##### 302 临时移动

临时重定向，302 表示资源临时移动，非永久移动。

##### 304 未修改

这个是个特殊的 3XX 状态码，并不属于重定向。

304 代表自从上次请求后，请求的网页未修改过。 服务器返回此响应时，不会返回网页内容。缓存相关状态码，需要配合响应头 `Last-Modified` 和 `Etag` 处理。

#### 4XX 客户端错误

现在的后端接口开发，4XX 是很常用的状态码。4XX 代表客户端发生错误，可能是参数错误、请求头错误等、请求冲突等情况。

##### 400 请求错误

改状态码表示请求报文中存在语法错误，如参数错误、请求头错误等。一般这种情况下都是前端开发者没按照后端接口协议来处理请求导致的错误，正式环境下是不应该出现这种错误的，否则说明 web 应用还有 bug。

##### 401 未授权

请求要求身份验证。 对于需要登录的网页，服务器可能返回此响应。 一般都是未登录、或者登陆失效才会报 401 状态码。401 的情况下，需要跳转到登录页登录。

##### 403 禁止

一般都是已经登录，身份得到了认证，但是没有足够权限操作。一般在权限基本很严的系统会经常返回这个状态码。还有修改密码是原密码不正确也会应该返回 403 。

##### 404 未找到

这个是大家都很熟悉的状态码，代表服务器资源未找到。

#### 5XX 服务端错误

5XX 代表服务器本身发生错误，无法处理任何客户端请求。

##### 500 服务器内部错误

服务器遇到错误，无法完成请求。这种情况一般都是代码有 bug，执行途中发送错误，导致无法执行，程序崩溃等。

##### 502 网关错误

服务器作为网关或代理，从上游服务器收到无效响应。 

##### 503 服务不可用

该状态表明服务器处于超负载或者正在停机维护中。

##### 504   网关超时

服务器作为网关或代理，但是没有及时从上游服务器收到请求。

### Cookie

HTTP 为了保留无状态协议这个特性的同时又要解决类似的矛盾问题，于是引入了 Cookie 技术，通过在请求和响应报文中写入 Cookie 信息来控制客户端状态。

### 前端常用的 HTTP 请求方法

- GET

- HEAD

- POST

  新增资源。

- DELETE

  删除指定资源。

- PUT

  一般会用来更新一个已知资源，如果资源存在就替换，不存在就新增。

- PATCH

  是对 PUT 方法的补充，用来对已知资源进行**局部更新**。

### 网关与代理区别

网关和代理的区别在于：代理和上游服务器通信的协议还是 HTTP 协议，而网关和上游服务器通信的协议是非 HTTP 协议。

### 正向代理和方向代理

#### 正向代理

正向代理（forward proxy） ，一个位于客户端和原始服务器之间的服务器，为了从原始服务器取得内容，客户端向代理发送一个请求并制定目标（原始服务器），然后代理向原始服务器转发请求并将获得的内容返回给客户端，客户端才能使用正向代理。我们平时说的代理就是指正向代理。 

举个例子：A向C借钱，由于一些情况不能直接向C借钱，于是A想了一个办法，他让B去向C借钱，这样B就代替 A 向 C 借钱，A 就得到了C 的钱，C 并不知道 A 的存在，B就充当了 A 的代理人的角色。 

#### 反向代理

反向代理（Reverse Proxy），以代理服务器来接受 internet 上的连接请求，然后将请求转发给内部网络上的服务器，并将从服务器上得到的结果返回给internet上请求的客户端，此时代理服务器对外表现为一个反向代理服务器。 

理解起来有些抽象，举个例子：A 向 B 借钱，B 没有拿自己的钱，而是悄悄地向 C 借钱，拿到钱之后再交给 A，A 以为是 B 的钱，他并不知道 C 的存在。 

### HTTP 之 TCP/IP 的分层管理

> 这个问题在前端面试或许问的比较少，知道概念就好，我们没必要，也很难深入。

`TCP/IP` 按层次分为四层：

1. 应用层

   HTTP、FTP、DNS 等都属于应用层。

2. 传输层

   TCP 和 UDP。

3. 网络层

   网络层决定数据的路径选择和转寄。互联网可以简单理解为 IP。

4. 数据链路层

   如以太网、无线局域网等。

### HTTP 之 TCP 三次握手

一个完整的三次握手就是：请求（SYN） —  应答（SYN+ACK） —  再次确认（SYN）。

### HTTPS

HTTPS 跟 HTTP 有什么不一样呢？HTTPS，常称为 HTTP over TLS，HTTP over SSL 或 HTTP Secure。**通俗理解为： 安全的 HTTP 协议。**

由于 HTTP 有以下这些安全缺点：

- 通信使用明文（不加密），内容可能被窃听。
- 不验证通信方的身份，可能遭遇伪装。
- 无法证明报文的完整性，报文可能中途被串改了。

这些问题就需要一个安全的方式传输 HTTP 报文，所以就有了 HTTPS。

#### 简易理解 HTTPS

可以按照以下方式简单理解 HTTPS。

- HTTPS = HTTP + 加密 + 认证 + 完整性
- HTTPS 就是身披 SSL 外壳的 HTTP

#### 什么是 SSL

Secure Socket Layer，为[Netscape](https://baike.baidu.com/item/Netscape)所研发，用以保障在Internet上数据传输之安全，利用[数据加密](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E5%8A%A0%E5%AF%86)(Encryption)技术，可确保数据在网络上之传输过程中不会被截取及窃听。

SSL协议位于[TCP/IP协议](https://baike.baidu.com/item/TCP%2FIP%E5%8D%8F%E8%AE%AE)与各种[应用层](https://baike.baidu.com/item/%E5%BA%94%E7%94%A8%E5%B1%82)协议之间，为[数据通讯](https://baike.baidu.com/item/%E6%95%B0%E6%8D%AE%E9%80%9A%E8%AE%AF)提供安全支持。

#### HTTPS 加密方式

HTTPS 采用的是混合加密机制，首先使用**公开密钥加密方式**确认一条安全通道，然后在安全通道上使用**共享密钥加密方式**进行通信。

混合加密方式可以充分利用各自优势，提高响应速度。

##### 共享密钥加密

**加密和解密使用同一个密钥的方式称为共享密钥加密，也被称为对称密钥加密。**

使用**共享密钥加密**这种方式，也必须把密钥发给对方，但是只用这种加密方式是无法确保安全送达对方的。所有就有了下面的**公开密钥加密**。

##### 公开密钥加密

**公开密钥加密使用一对非对称的密钥。一把叫做私有密钥，另一把叫做公开密钥。**私有密钥是不能给任何人知道的，公开密钥是要发送给对方进行内容加密，然后加密的内容只能使用对应的私有密钥才能解密。

如果只想根据密文和公开密钥进行破解是异常困难的，目前的技术来说是不太现实的。

#### 如何确保公开密钥的正确性？

为了解决这个问题，就有了数字认证机构和相关机构发布的公开密钥证书。所以你有时候会在访问一些 https 域名时，会有安全提示，那是因为该网站 https 证书并不是认证机构发布的证书。

为了安全的转移网站的公开密钥到客户端，多数的浏览器开发商，在发布浏览器版本时，会事先在内部植入常用认证机构的公开密钥。

#### 为什么不一直使用 HTTPS

其中一个原因就是，加密通信会消耗更多 CPU 和内存资源。 HTTPS 比 HTTP 慢 2 到 100 倍左右（当然不包括后端处理时间，和响应主体大小）。一个请求可能没什么感觉，但是当请求上亿或者更多时，这个消耗是可以明显的。所有看情况决定是否使用 https。

### WebSocket

WebSocket 即 Web 浏览器和 Web 浏览器之间全双工通信标准。

### HTTP 2.0 和 HTTP 1.1 最大区别

#### 二进制分帧

在应用层与传输层之间增加一个二进制分帧层，以此达到“在不改动HTTP的语义，HTTP 方法、状态码、URI及首部字段的情况下，突破 HTTP 1.1 的性能限制，改进传输性能，实现低延迟和高吞吐量。

在二进制分帧层上，HTTP 2.0 会将所有传输的信息分割为更小的消息和帧,并对它们采用二进制格式的编码，其中HTTP 1.x 的首部信息会被封装到 Headers 帧，而我们的 request body 则封装到 Data 帧里面。

#### 压缩头部

HTTP 2.0 规定了在客户端和服务器端会使用并且维护`首部表`来跟踪和存储之前发送的键值对，对于相同的头部，不必再通过请求发送，只需发送一次。

事实上,如果请求中不包含首部（例如对同一资源的轮询请求），那么首部开销就是零字节。此时所有首部都自动使用之前请求发送的首部。

如果首部发生变化了，那么只需要发送变化了数据在 Headers 帧里面，新增或修改的首部帧会被追加到`首部表`。首部表在 HTTP 2.0 的连接存续期内始终存在，由客户端和服务器共同渐进地更新。

#### 数据压缩

HTTP 1.1 不支持 header 数据的压缩，HTTP 2.0 使用 HPACK 算法对 header 的数据进行压缩，这样数据体积小了，在网络上传输就会更快。

#### 多路复用

HTTP 1.1 持久连接解决了连接复用问题，但还是存在着一个问题，一个 TCP 无法并发处理请求：在一个 TCP 连接中，同一时间只能够发送一个请求，并且需要等响应完成才能够发送第二个请求。

HTTP 2.0 使用了多路复用的技术，做到同一个连接并发处理多个请求，而且并发请求的数量比 HTTP 1.1 大了好几个数量级。

当然 HTTP 1.1 也可以多建立几个 TCP 连接，来支持处理更多并发的请求，但是创建TCP连接本身也是有开销的。

TCP 连接有一个预热和保护的过程，先检查数据是否传送成功，一旦成功过，则慢慢加大传输速度。因此对应瞬时并发的连接，服务器的响应就会变慢。所以最好能使用一个建立好的连接，并且这个连接可以支持瞬时并发的请求。

有多路复用特性，那么浏览器对同一域名的链接数的限制也是没必要的了（HTTP 1.1 的谷歌对统一域名并发请求最多支持 6个 持久链接）。

#### 请求优先级

既然所有资源都是并行发送，那么就需要优先级的概念了，这样就可以对重要的文件进行先传输，加速页面的渲染。







